{"version":3,"sources":["serviceWorker.ts","index.tsx","context/globalContext.ts","helpers/helpers.ts","App.tsx","components/chatBox.tsx","components/walletDisplay.tsx"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","initialState","addressBook","reverseAddressBook","messageList","reducer","state","action","type","web3","payload","waku","address","onboard","keys","reverseAddress","Object","values","GlobalContext","React","createContext","dispatch","formatAddress","substring","length","encryptMessage","publicKey","a","childSig","EthCrypto","sign","privateKey","hash","keccak256","encryptWithPublicKey","JSON","stringify","encryptedMessage","cipher","ChatContentTopic","AddressBroadcastTopic","useReducer","toast","useToast","handleChatMessage","wakuMsg","decryptWithPrivateKey","parse","payloadAsUtf8","decryptedMessage","decryptedPayload","childKeyVer","recoverPublicKey","from","position","title","description","status","duration","isClosable","log","handleHistoricalChatMessage","handleAddressBroadcastMessage","msg","chatKey","toLowerCase","err","handleProtocolChange","peerId","protocols","includes","StoreCodec","store","queryHistory","contentTopics","direction","Direction","FORWARD","response","map","toB58String","startUp","Waku","create","config","pubsub","enabled","emitSelf","addPeerToAddressBook","relay","addObserver","libp2p","peerStore","on","bind","deriveChatKey","getSigner","signMessage","signature","createIdentity","Buffer","chatKeyPair","broadcastChatKey","signedPubKeysignature","WakuMessage","fromUtf8String","send","handleConnect","wallets","walletName","preferred","Onboard","networkId","subscriptions","wallet","ethers","providers","Web3Provider","provider","balance","network","chain","walletSelect","Provider","value","h","mw","disabled","onClick","undefined","in","ChatBox","useContext","useState","setList","msgText","setMsg","toAddress","setTo","useEffect","updatedList","slice","handleMessageSend","to","minHeight","isInvalid","placeholder","onChange","evt","target","aria-label","icon","variant","colorScheme","w","spacing","fontWeight","diameter","seed","jsNumberForAddress","WalletDisplay","placement","size","walletReset"],"mappings":"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","file":"static/js/main.0cda1aff.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ChakraProvider } from \"@chakra-ui/react\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ChakraProvider>\n      <App />\n    </ChakraProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { ethers } from \"ethers\";\n\nimport React from \"react\";\nimport { Waku } from \"js-waku\";\n\nexport type ethIdentity = {\n  privateKey: string;\n  publicKey: string;\n  address: string;\n};\n\nexport type message = {\n  from: string;\n  message: string;\n};\n\nexport type globalState = {\n  web3?: ethers.providers.Web3Provider;\n  address?: string;\n  onboard?: any;\n  waku?: Waku;\n  keys?: ethIdentity;\n  addressBook?: {\n    [key: string]: string;\n  };\n  reverseAddressBook?: {\n    [key: string]: string;\n  };\n  messageList: message[];\n};\n\nexport const initialState = {\n  addressBook: {},\n  reverseAddressBook: {},\n  messageList: [],\n};\n\nexport const reducer = (state: globalState, action: any): globalState => {\n  switch (action.type) {\n    case \"SET_WEB3\": {\n      return { ...state, web3: action.payload.web3 };\n    }\n    case \"START_WAKU\": {\n      return { ...state, waku: action.payload.waku };\n    }\n    case \"SET_ADDRESS\": {\n      return { ...state, address: action.payload.address };\n    }\n    case \"SET_ONBOARD\": {\n      return { ...state, onboard: action.payload.onboard };\n    }\n    case \"SET_KEYS\": {\n      return { ...state, keys: action.payload.keys };\n    }\n    case \"ADD_PEER\": {\n      let reverseAddress = {\n        [Object.values(action.payload)[0] as string]: Object.keys(\n          action.payload\n        )[0],\n      };\n\n      return {\n        ...state,\n        addressBook: {...state.addressBook, ...action.payload},\n        reverseAddressBook: {...state.reverseAddressBook,\n          ...reverseAddress},\n      };\n    }\n    case \"ADD_MESSAGE\": {\n      return { ...state, messageList: [...state.messageList, action.payload] };\n    }\n    default:\n      return state;\n  }\n};\n\nconst GlobalContext = React.createContext<{\n  state: globalState;\n  dispatch: React.Dispatch<any>;\n}>({ state: initialState, dispatch: () => null });\n\nexport { GlobalContext as default };\n","import EthCrypto from 'eth-crypto';\nimport { ethIdentity } from '../context/globalContext';\n\nexport const formatAddress = (address: string) => {\n    return (\n      address ? address.substring(0, 4) + \"...\" + address.substring(address.length - 4) : 'Unknown Sender'\n    );\n  };\n  \nexport const encryptMessage = async (keys: ethIdentity, publicKey: string, message: string) => {\n  const payload = {\n    message: message,\n    childSig: EthCrypto.sign(keys.privateKey, EthCrypto.hash.keccak256(message))\n  }\n  const encryptedMessage = await EthCrypto.encryptWithPublicKey(publicKey, JSON.stringify(payload));\n  return EthCrypto.cipher.stringify(encryptedMessage);\n}","import {\n  Button,\n  Center,\n  Heading,\n  HStack,\n  SlideFade,\n  useToast,\n  VStack,\n} from \"@chakra-ui/react\";\nimport Onboard from \"bnc-onboard\";\nimport EthCrypto from \"eth-crypto\";\nimport { ethers } from \"ethers\";\nimport { StoreCodec, Waku, WakuMessage } from \"js-waku\";\nimport { Direction } from \"js-waku/build/main/lib/waku_store/history_rpc\";\nimport PeerId from \"peer-id\";\nimport React from \"react\";\nimport ChatBox from \"./components/chatBox\";\nimport WalletDisplay from \"./components/walletDisplay\";\nimport GlobalContext, { initialState, reducer } from \"./context/globalContext\";\nimport { formatAddress } from \"./helpers/helpers\";\n\nlet web3: ethers.providers.Web3Provider;\n\nexport const ChatContentTopic = \"wakumono/dm\";\nexport const AddressBroadcastTopic = \"wakumono/broadcast\";\nfunction App() {\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n  const toast = useToast();\n\n  const handleChatMessage = async (wakuMsg: WakuMessage) => {\n    if (wakuMsg.payload && state.keys && state.reverseAddressBook) {\n      try {\n        const decryptedMessage = await EthCrypto.decryptWithPrivateKey(\n          state.keys!.privateKey,\n          EthCrypto.cipher.parse(wakuMsg.payloadAsUtf8)\n        );\n        const decryptedPayload = JSON.parse(decryptedMessage);\n        const childKeyVer = EthCrypto.recoverPublicKey(\n          decryptedPayload.childSig,\n          EthCrypto.hash.keccak256(decryptedPayload.message)\n        );\n        dispatch({\n          type: \"ADD_MESSAGE\",\n          payload: {\n            from: state.reverseAddressBook[childKeyVer],\n            message: decryptedPayload.message,\n          },\n        });\n        toast({\n          position: \"bottom\",\n          title:\n            \"Message received from \" +\n            formatAddress(state.reverseAddressBook[childKeyVer]),\n          description: decryptedPayload.message,\n          status: \"success\",\n          duration: 3000,\n          isClosable: true,\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  };\n  const handleHistoricalChatMessage = async (wakuMsg: WakuMessage) => {\n    if (wakuMsg.payload && state.keys && state.reverseAddressBook) {\n      try {\n        const decryptedMessage = await EthCrypto.decryptWithPrivateKey(\n          state.keys!.privateKey,\n          EthCrypto.cipher.parse(wakuMsg.payloadAsUtf8)\n        );\n        const decryptedPayload = JSON.parse(decryptedMessage);\n        const childKeyVer = EthCrypto.recoverPublicKey(\n          decryptedPayload.childSig,\n          EthCrypto.hash.keccak256(decryptedPayload.message)\n        );\n        dispatch({\n          type: \"ADD_MESSAGE\",\n          payload: {\n            from: childKeyVer ?? \"unknown sender\",\n            message: decryptedPayload.message,\n          },\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  };\n\n  const handleAddressBroadcastMessage = async (wakuMsg: WakuMessage) => {\n    try {\n      const msg = JSON.parse(wakuMsg.payloadAsUtf8);\n      if (msg.chatKey) {\n        dispatch({\n          type: \"ADD_PEER\",\n          payload: { [msg.address.toLowerCase()]: msg.chatKey },\n        });\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  const handleProtocolChange = async (\n    waku: Waku,\n    { peerId, protocols }: { peerId: PeerId; protocols: string[] }\n  ) => {\n    if (protocols.includes(StoreCodec)) {\n      try {\n        const response = await waku.store.queryHistory({\n          peerId: peerId,\n          contentTopics: [AddressBroadcastTopic],\n          direction: Direction.FORWARD,\n        });\n        if (response) {\n          await response.map((wakuMsg) =>\n            handleAddressBroadcastMessage(wakuMsg)\n          );\n        }\n      } catch (e) {\n        console.log(\n          `${peerId.toB58String()}: error encountered when retrieving archived messages`,\n          e\n        );\n      }\n      try {\n        const response = await waku.store.queryHistory({\n          peerId: peerId,\n          contentTopics: [ChatContentTopic],\n        });\n        if (response) {\n          response.map((wakuMsg) => handleHistoricalChatMessage(wakuMsg));\n        }\n      } catch (e) {\n        console.log(\n          `${peerId.toB58String()}: error encountered when retrieving archived messages`,\n          e\n        );\n      }\n    }\n  };\n  const startUp = async () => {\n    try {\n      const waku = await Waku.create({\n        config: {\n          pubsub: {\n            enabled: true,\n            emitSelf: true,\n          },\n        },\n      });\n\n      waku.addPeerToAddressBook(\n        \"16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ\",\n        [\"/dns4/node-01.do-ams3.jdev.misc.statusim.net/tcp/7010/wss\"]\n      );\n\n      waku.addPeerToAddressBook(\n        \"16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA\",\n        [\n          \"/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/443/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA\",\n        ]\n      );\n\n      /*    \n      const nodes = await getStatusFleetNodes(Environment.Prod);\n      await Promise.all(\n        nodes.map((addr) => {\n          return waku.dial(addr);\n        })\n      );\n*/\n      dispatch({ type: \"START_WAKU\", payload: { waku: waku } });\n      waku.relay.addObserver(handleChatMessage, [ChatContentTopic]);\n      waku.relay.addObserver(handleAddressBroadcastMessage, [\n        AddressBroadcastTopic,\n      ]);\n      waku.libp2p.peerStore.on(\n        \"change:protocols\",\n        handleProtocolChange.bind({}, waku)\n      );\n    } catch (e) {\n      console.log(\"Issue starting waku \", e);\n    }\n  };\n\n  const deriveChatKey = async () => {\n    let signature = await web3\n      .getSigner()\n      .signMessage(\"make it so, Number One\");\n    let chatKeyPair = await EthCrypto.createIdentity(Buffer.from(signature));\n    dispatch({ type: \"SET_KEYS\", payload: { keys: chatKeyPair } });\n  };\n\n  const broadcastChatKey = async () => {\n    if (!state.keys) {\n      return;\n    }\n\n    const signedPubKeysignature = await web3\n      .getSigner()\n      .signMessage(state.keys.address);\n    const msg = WakuMessage.fromUtf8String(\n      JSON.stringify({\n        address: state.address,\n        chatKey: state.keys.publicKey,\n        signature: signedPubKeysignature,\n      }),\n      AddressBroadcastTopic\n    );\n    state.waku?.relay.send(msg);\n  };\n\n  const handleConnect = async () => {\n    const wallets = [\n      { walletName: \"metamask\", preferred: true },\n      { walletName: \"status\", preferred: true },\n    ];\n    const onboard = Onboard({\n      networkId: 1,\n      subscriptions: {\n        wallet: async (wallet) => {\n          try {\n            web3 = new ethers.providers.Web3Provider(wallet.provider);\n            dispatch({ type: \"SET_WEB3\", payload: { web3: web3 } });\n            deriveChatKey();\n          } catch (err) {\n            console.log(err);\n          }\n        },\n        address: (address) => {\n          dispatch({ type: \"SET_ADDRESS\", payload: { address: address } });\n        },\n        balance: (balance) => {\n          dispatch({ type: \"SET_BALANCE\", payload: { balance: balance } });\n        },\n        network: (network) => {\n          dispatch({ type: \"SET_CHAIN\", payload: { chain: network } });\n        },\n      },\n      walletSelect: {\n        wallets: wallets,\n      },\n    });\n\n    dispatch({ type: \"SET_ONBOARD\", payload: { onboard: onboard } });\n    try {\n      await onboard.walletSelect();\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  return (\n    <GlobalContext.Provider value={{ dispatch, state }}>\n      <Center h=\"90vh\" mw=\"95vw\">\n        <VStack>\n          <Heading>WakuMono</Heading>\n          <HStack>\n            <WalletDisplay handleConnect={handleConnect} />\n            <Button disabled={!state.keys} onClick={startUp}>\n              Connect to Waku\n            </Button>\n            <Button\n              disabled={state.addressBook![state.address!] !== undefined}\n              onClick={broadcastChatKey}\n            >\n              Broadcast Chatkey\n            </Button>\n          </HStack>\n          <SlideFade in={state.waku !== undefined}>\n            <ChatBox />\n          </SlideFade>\n        </VStack>\n      </Center>\n    </GlobalContext.Provider>\n  );\n}\n\nexport default App;\n","import {\n  Box,\n  Center,\n  FormControl,\n  FormErrorMessage,\n  Heading,\n  HStack,\n  IconButton,\n  Input,\n  SlideFade,\n  VStack,\n  Text\n} from \"@chakra-ui/react\";\nimport { WakuMessage } from \"js-waku\";\nimport React from \"react\";\nimport { BiMailSend } from \"react-icons/bi\";\n//@ts-ignore\nimport Jazzicon, { jsNumberForAddress } from 'react-jazzicon'\nimport { ChatContentTopic } from \"../App\";\nimport GlobalContext, { message } from \"../context/globalContext\";\nimport { encryptMessage, formatAddress } from \"../helpers/helpers\";\n\nconst ChatBox = () => {\n  const { state } = React.useContext(GlobalContext);\n  const [messageList, setList] = React.useState<message[]>([]);\n  const [msgText, setMsg] = React.useState(\"\");\n  const [toAddress, setTo] = React.useState(\"\");\n\n  React.useEffect(() => {\n    const updatedList =\n      state.messageList.length < 10\n        ? state.messageList\n        : state.messageList.slice(state.messageList.length - 11);\n    setList(updatedList);\n  }, [state.messageList]);\n\n  const handleMessageSend = async (to: string, msgText: string) => {\n    if (!state.web3 || !state.keys) {\n      return;\n    }\n\n    if (!state.addressBook![to.toLowerCase()]) {\n      console.log(\"no address found\");\n      return;\n    }\n    const encryptedMessage = await encryptMessage(\n      state.keys,\n      state.addressBook![to.toLowerCase()],\n      msgText\n    );\n    const msg = WakuMessage.fromUtf8String(encryptedMessage, ChatContentTopic);\n    state.waku?.relay.send(msg);\n    setMsg(\"\");\n  };\n\n  return (\n    <VStack mw=\"90vw\">\n      <FormControl\n        minHeight=\"100px\"\n        isInvalid={\n          toAddress !== \"\" && state.addressBook![toAddress] === undefined\n        }\n      >\n        <HStack>\n          <Input\n            value={toAddress}\n            placeholder=\"Address\"\n            onChange={(evt) => setTo(evt.target.value)}\n          />\n          <Input\n            value={msgText}\n            placeholder=\"Enter a message\"\n            onChange={(evt) => setMsg(evt.target.value)}\n          />\n          <IconButton\n            disabled={state.addressBook![toAddress.toLowerCase()] === undefined}\n            onClick={() => {\n              handleMessageSend(toAddress, msgText);\n            }}\n            aria-label=\"send message\"\n            icon={<BiMailSend />}\n            variant=\"outline\"\n            colorScheme=\"blackAlpha\"\n          />\n        </HStack>\n        <SlideFade\n          in={toAddress !== \"\" && state.addressBook![toAddress] === undefined}\n        >\n          <FormErrorMessage>Address not found</FormErrorMessage>\n        </SlideFade>\n      </FormControl>\n\n      <Heading>Inbox</Heading>\n      <HStack w=\"75vw\" spacing=\"24px\">\n        <Box fontWeight=\"bold\" w=\"150px\">\n          Sender\n        </Box>\n        <Box fontWeight=\"bold\">Message</Box>\n      </HStack>\n      {messageList.map((msg: message) => {\n        return (\n          <HStack w=\"75vw\" spacing=\"24px\">\n            <HStack w=\"150px\">\n              <Jazzicon diameter={20} seed={jsNumberForAddress(msg.from)} />\n              <Text>{formatAddress(state.reverseAddressBook![msg.from])}</Text>\n            </HStack>\n            <Box>{msg.message}</Box>\n          </HStack>\n        );\n      })}\n    </VStack>\n  );\n};\n\nexport default ChatBox;\n","import React from \"react\";\nimport {\n  Box,\n  Button,\n  Popover,\n  PopoverTrigger,\n  PopoverContent,\n  PopoverHeader,\n  PopoverBody,\n  PopoverArrow,\n  PopoverCloseButton,\n  Heading,\n  VStack,\n} from \"@chakra-ui/react\";\nimport GlobalContext from \"../context/globalContext\";\nimport { formatAddress } from \"../helpers/helpers\";\n\ntype WalletProps = {\n  handleConnect: () => void;\n};\n\nconst WalletDisplay: React.FC<WalletProps> = ({ handleConnect }) => {\n  const { state, dispatch } = React.useContext(GlobalContext);\n\n  const handleClick = () => {\n    if (state.onboard) {\n      state.onboard.walletReset();\n      dispatch({ type: \"SET_ADDRESS\", payload: { address: undefined } });\n      dispatch({ type: \"SET_WEB3\", payload: { web3: undefined } });\n    }\n  };\n\n  return (\n    <Box>\n      {state.address ? (\n        <Popover placement=\"top\">\n          <PopoverTrigger>\n            <Button w=\"200px\">\n              {formatAddress(state.address)}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent>\n            <PopoverArrow />\n            <PopoverCloseButton />\n            <PopoverHeader>\n              <Heading size=\"sm\">Wallet Details</Heading>\n            </PopoverHeader>\n            <PopoverBody>\n              <VStack>\n                <Button onClick={handleClick}>Disconnect Wallet</Button>\n              </VStack>\n            </PopoverBody>\n          </PopoverContent>\n        </Popover>\n      ) : (\n        <Button w=\"200px\" onClick={handleConnect}>\n          Connect Web3\n        </Button>\n      )}\n    </Box>\n  );\n};\n\nexport default WalletDisplay;\n"],"sourceRoot":""}