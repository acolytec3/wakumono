{"version":3,"sources":["serviceWorker.ts","index.tsx","context/globalContext.ts","helpers/helpers.ts","App.tsx","components/walletDisplay.tsx","components/chatBox.tsx"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","initialState","addressBook","reverseAddressBook","messageList","reducer","state","action","type","web3","payload","waku","address","onboard","keys","reverseAddress","Object","values","log","assign","GlobalContext","React","createContext","dispatch","formatAddress","substring","length","encryptMessage","publicKey","a","childSig","EthCrypto","sign","privateKey","hash","keccak256","encryptWithPublicKey","JSON","stringify","encryptedMessage","cipher","ChatContentTopic","AddressBroadcastTopic","useReducer","toast","useToast","handleChatMessage","wakuMsg","decryptWithPrivateKey","parse","payloadAsUtf8","decryptedMessage","decryptedPayload","childKeyVer","recoverPublicKey","from","position","title","description","status","duration","isClosable","handleHistoricalChatMessage","handleAddressBroadcastMessage","msg","chatKey","toLowerCase","err","handleProtocolChange","peerId","protocols","includes","StoreCodec","store","queryHistory","contentTopics","direction","Direction","FORWARD","response","map","broadcastChatKey","toB58String","startUp","Waku","create","config","pubsub","enabled","emitSelf","addPeerToAddressBook","relay","addObserver","libp2p","peerStore","on","bind","useEffect","removeListener","deriveChatKey","getSigner","signMessage","signature","createIdentity","Buffer","chatKeyPair","signedPubKeysignature","WakuMessage","fromUtf8String","send","handleConnect","wallets","walletName","preferred","Onboard","networkId","subscriptions","wallet","ethereum","enable","ethers","providers","Web3Provider","provider","toString","balance","network","chain","walletSelect","Provider","value","h","disabled","onClick","in","undefined","WalletDisplay","useContext","placement","w","size","walletReset","ChatBox","useState","setList","msgText","setMsg","toAddress","setTo","handleMessageSend","to","placeholder","onChange","evt","target","minWidth","Math","random"],"mappings":"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","file":"static/js/main.d65a04f7.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","\nimport { ethers } from 'ethers'\n\nimport React from 'react'\nimport { Waku } from 'js-waku';\n\nexport type ethIdentity = {\n  privateKey: string,\n  publicKey: string,\n  address: string\n}\n\nexport type message = {\n  from: string,\n  message: string\n}\n\nexport type globalState = {\n    web3?: ethers.providers.Web3Provider,\n    address?: string,\n    onboard?: any,\n    waku?: Waku,\n    keys?: ethIdentity,\n    addressBook?: {\n      [key: string]: string\n    },\n    reverseAddressBook?: {\n      [key: string]: string\n    },\n    messageList: message[]\n  }\n  \n  export const initialState = {\n    addressBook: {},\n    reverseAddressBook: {},\n    messageList: []\n  }\n  \n  \n  export const reducer = (state: globalState, action: any): globalState => {\n    switch (action.type) {\n      case 'SET_WEB3': {\n        return { ...state, web3: action.payload.web3 };\n      }\n      case 'START_WAKU': {\n        return { ...state, waku: action.payload.waku };\n      }\n      case 'SET_ADDRESS': {\n        return { ...state, address: action.payload.address };\n      }\n      case 'SET_ONBOARD': {\n        return { ...state, onboard: action.payload.onboard };\n      }\n      case 'SET_KEYS': {\n        return { ...state, keys: action.payload.keys };\n      }\n      case 'ADD_PEER': {\n        let reverseAddress = { [Object.values(action.payload)[0] as string] : Object.keys(action.payload)[0] };\n        console.log(reverseAddress);\n        return {...state, addressBook: Object.assign(state.addressBook, action.payload), reverseAddressBook: Object.assign(state.reverseAddressBook, reverseAddress)}\n      }\n      case 'ADD_MESSAGE': { \n        return {...state, messageList: [...state.messageList, action.payload]}\n      }\n      default:\n        return state;\n    }\n  }\n\n  const GlobalContext = React.createContext<{state:globalState, dispatch: React.Dispatch<any>}>({state: initialState, dispatch: () => null})\n\n  export { GlobalContext as default } ","import EthCrypto from 'eth-crypto';\nimport { ethIdentity } from '../context/globalContext';\n\nexport const formatAddress = (address: string) => {\n    return (\n      address.substring(0, 4) + \"...\" + address.substring(address.length - 4)\n    );\n  };\n  \nexport const encryptMessage = async (keys: ethIdentity, publicKey: string, message: string) => {\n  const payload = {\n    message: message,\n    childSig: EthCrypto.sign(keys.privateKey, EthCrypto.hash.keccak256(message))\n  }\n  const encryptedMessage = await EthCrypto.encryptWithPublicKey(publicKey, JSON.stringify(payload));\n  return EthCrypto.cipher.stringify(encryptedMessage);\n}","import {\n  Button,\n  Center,\n  ChakraProvider,\n  Heading,\n  HStack,\n  Input,\n  SlideFade,\n  useToast,\n  VStack,\n} from \"@chakra-ui/react\";\nimport Onboard from \"bnc-onboard\";\nimport { ethers } from \"ethers\";\nimport {\n  Environment,\n  getStatusFleetNodes,\n  StoreCodec,\n  Waku,\n  WakuMessage,\n} from \"js-waku\";\nimport PeerId from \"peer-id\";\nimport React from \"react\";\nimport WalletDisplay from \"./components/walletDisplay\";\nimport GlobalContext, { initialState, reducer } from \"./context/globalContext\";\nimport EthCrypto from \"eth-crypto\";\nimport ChatBox from \"./components/chatBox\";\nimport { Direction } from \"js-waku/build/main/lib/waku_store/history_rpc\";\nimport { formatAddress } from \"./helpers/helpers\";\n\nlet web3: ethers.providers.Web3Provider;\n\nexport const ChatContentTopic = \"wakumono/dm\";\nexport const AddressBroadcastTopic = \"wakumono/broadcast\";\nfunction App() {\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n  const toast = useToast();\n\n  const handleChatMessage = async (wakuMsg: WakuMessage) => {\n    if (wakuMsg.payload && state.keys && state.reverseAddressBook) {\n      try {\n        const decryptedMessage = await EthCrypto.decryptWithPrivateKey(\n          state.keys!.privateKey,\n          EthCrypto.cipher.parse(wakuMsg.payloadAsUtf8)\n        );\n        const decryptedPayload = JSON.parse(decryptedMessage);\n        const childKeyVer = EthCrypto.recoverPublicKey(\n          decryptedPayload.childSig,\n          EthCrypto.hash.keccak256(decryptedPayload.message)\n        );\n        dispatch({\n          type: \"ADD_MESSAGE\",\n          payload: {\n            from: state.reverseAddressBook[childKeyVer],\n            message: decryptedPayload.message,\n          },\n        });\n        toast({\n          position: \"bottom\",\n          title:\n            \"Message received from \" +\n            formatAddress(state.reverseAddressBook[childKeyVer]),\n          description: decryptedPayload.message,\n          status: \"success\",\n          duration: 3000,\n          isClosable: true,\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  };\n  const handleHistoricalChatMessage = async (wakuMsg: WakuMessage) => {\n    if (wakuMsg.payload && state.keys && state.reverseAddressBook) {\n      try {\n        const decryptedMessage = await EthCrypto.decryptWithPrivateKey(\n          state.keys!.privateKey,\n          EthCrypto.cipher.parse(wakuMsg.payloadAsUtf8)\n        );\n        const decryptedPayload = JSON.parse(decryptedMessage);\n        const childKeyVer = EthCrypto.recoverPublicKey(\n          decryptedPayload.childSig,\n          EthCrypto.hash.keccak256(decryptedPayload.message)\n        );\n        dispatch({\n          type: \"ADD_MESSAGE\",\n          payload: {\n            from: state.reverseAddressBook[childKeyVer],\n            message: decryptedPayload.message,\n          },\n        });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  };\n\n  const handleAddressBroadcastMessage = async (wakuMsg: WakuMessage) => {\n    try {\n      const msg = JSON.parse(wakuMsg.payloadAsUtf8);\n      if (msg.chatKey) {\n        dispatch({\n          type: \"ADD_PEER\",\n          payload: { [msg.address.toLowerCase()]: msg.chatKey },\n        });\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  const handleProtocolChange = async (\n    waku: Waku,\n    { peerId, protocols }: { peerId: PeerId; protocols: string[] }\n  ) => {\n    if (protocols.includes(StoreCodec)) {\n      try {\n        const response = await waku.store.queryHistory({\n          peerId: peerId,\n          contentTopics: [AddressBroadcastTopic],\n          direction: Direction.FORWARD,\n        });\n        if (response) {\n          await response.map((wakuMsg) =>\n            handleAddressBroadcastMessage(wakuMsg)\n          );\n          if (!state.addressBook![state.address!]) {\n            await broadcastChatKey();\n          }\n        }\n      } catch (e) {\n        console.log(\n          `${peerId.toB58String()}: error encountered when retrieving archived messages`,\n          e\n        );\n      }\n      try {\n        const response = await waku.store.queryHistory({\n          peerId: peerId,\n          contentTopics: [ChatContentTopic],\n        });\n        if (response) {\n          response.map((wakuMsg) => handleHistoricalChatMessage(wakuMsg));\n        }\n      } catch (e) {\n        console.log(\n          `${peerId.toB58String()}: error encountered when retrieving archived messages`,\n          e\n        );\n      }\n    }\n  };\n  const startUp = async () => {\n    try {\n      const waku = await Waku.create({\n        config: {\n          pubsub: {\n            enabled: true,\n            emitSelf: true,\n          },\n        },\n      });\n\n      waku.addPeerToAddressBook(\n        \"16Uiu2HAmPLe7Mzm8TsYUubgCAW1aJoeFScxrLj8ppHFivPo97bUZ\",\n        [\"/dns4/node-01.do-ams3.jdev.misc.statusim.net/tcp/7010/wss\"]\n      );\n\n      waku.addPeerToAddressBook(\n        \"16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA\",\n        [\n          \"/dns4/node-01.gc-us-central1-a.wakuv2.prod.statusim.net/tcp/443/wss/p2p/16Uiu2HAmVkKntsECaYfefR1V2yCR79CegLATuTPE6B9TxgxBiiiA\",\n        ]\n      );\n\n      /*    \n      const nodes = await getStatusFleetNodes(Environment.Prod);\n      await Promise.all(\n        nodes.map((addr) => {\n          return waku.dial(addr);\n        })\n      );\n*/\n      dispatch({ type: \"START_WAKU\", payload: { waku: waku } });\n      waku.relay.addObserver(handleChatMessage, [ChatContentTopic]);\n      waku.relay.addObserver(handleAddressBroadcastMessage, [\n        AddressBroadcastTopic,\n      ]);\n      waku.libp2p.peerStore.on(\n        \"change:protocols\",\n        handleProtocolChange.bind({}, waku)\n      );\n    } catch (e) {\n      console.log(\"Issue starting waku \", e);\n    }\n  };\n\n  React.useEffect(() => {\n    return () => {\n      state.waku?.libp2p.peerStore.removeListener(\n        \"change:protocols\",\n        handleProtocolChange.bind({}, state.waku)\n      );\n    };\n  }, []);\n\n  const deriveChatKey = async () => {\n    let signature = await web3\n      .getSigner()\n      .signMessage(\"make it so, Number One\");\n    let chatKeyPair = await EthCrypto.createIdentity(Buffer.from(signature));\n    dispatch({ type: \"SET_KEYS\", payload: { keys: chatKeyPair } });\n  };\n\n  const broadcastChatKey = async () => {\n    if (!state.keys) {\n      return;\n    }\n\n    const signedPubKeysignature = await web3\n      .getSigner()\n      .signMessage(state.keys.address);\n    const msg = WakuMessage.fromUtf8String(\n      JSON.stringify({\n        address: state.address,\n        chatKey: state.keys.publicKey,\n        signature: signedPubKeysignature,\n      }),\n      AddressBroadcastTopic\n    );\n    state.waku?.relay.send(msg);\n  };\n\n  const handleConnect = async () => {\n    const wallets = [{ walletName: \"metamask\", preferred: true }];\n    const onboard = Onboard({\n      networkId: 1,\n      subscriptions: {\n        wallet: async (wallet) => {\n          try {\n            //@ts-ignore\n            if (window.ethereum) {\n              //@ts-ignore\n              window.ethereum.enable();\n            }\n            web3 = new ethers.providers.Web3Provider(wallet.provider);\n            dispatch({ type: \"SET_WEB3\", payload: { web3: web3 } });\n            deriveChatKey();\n          } catch (err) {\n            console.log(err);\n            toast({\n              position: \"top\",\n              status: \"error\",\n              title: \"Something went wrong\",\n              description: err?.toString(),\n              duration: 5000,\n            });\n          }\n        },\n        address: (address) => {\n          dispatch({ type: \"SET_ADDRESS\", payload: { address: address } });\n        },\n        balance: (balance) => {\n          dispatch({ type: \"SET_BALANCE\", payload: { balance: balance } });\n        },\n        network: (network) => {\n          dispatch({ type: \"SET_CHAIN\", payload: { chain: network } });\n        },\n      },\n      walletSelect: {\n        wallets: wallets,\n      },\n    });\n\n    dispatch({ type: \"SET_ONBOARD\", payload: { onboard: onboard } });\n    try {\n      const walletSelected = await onboard.walletSelect();\n    } catch (err) {\n      console.log(err);\n      toast({\n        position: \"top\",\n        status: \"error\",\n        title: \"Something went wrong\",\n        description: err?.toString(),\n        duration: 5000,\n      });\n    }\n  };\n\n  return (\n    <ChakraProvider>\n      <GlobalContext.Provider value={{ dispatch, state }}>\n        <Center h=\"90vh\">\n          <VStack>\n            <Heading>WakuMono</Heading>\n            <HStack>\n              <WalletDisplay handleConnect={handleConnect} />\n              <Button disabled={!state.web3} onClick={startUp}>\n                Connect to Waku\n              </Button>\n            </HStack>\n            <SlideFade in={state.waku !== undefined}>\n              <ChatBox />\n            </SlideFade>\n          </VStack>\n        </Center>\n      </GlobalContext.Provider>\n    </ChakraProvider>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport {\n  Box,\n  Button,\n  Popover,\n  PopoverTrigger,\n  PopoverContent,\n  PopoverHeader,\n  PopoverBody,\n  PopoverArrow,\n  PopoverCloseButton,\n  Heading,\n  Text,\n  VStack,\n} from \"@chakra-ui/react\";\nimport GlobalContext from \"../context/globalContext\";\nimport { formatAddress } from \"../helpers/helpers\";\n\ntype WalletProps = {\n  handleConnect: () => void;\n};\n\nconst WalletDisplay: React.FC<WalletProps> = ({ handleConnect }) => {\n  const { state, dispatch } = React.useContext(GlobalContext);\n\n  const handleClick = () => {\n    if (state.onboard) {\n      state.onboard.walletReset();\n      dispatch({ type: \"SET_ADDRESS\", payload: { address: undefined } });\n      dispatch({ type: \"SET_WEB3\", payload: { web3: undefined } });\n    }\n  };\n\n  return (\n    <Box>\n      {state.address ? (\n        <Popover placement=\"top\">\n          <PopoverTrigger>\n            <Button w=\"250px\">\n              {formatAddress(state.address)}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent>\n            <PopoverArrow />\n            <PopoverCloseButton />\n            <PopoverHeader>\n              <Heading size=\"sm\">Wallet Details</Heading>\n            </PopoverHeader>\n            <PopoverBody>\n              <VStack>\n                <Button onClick={handleClick}>Disconnect Wallet</Button>\n              </VStack>\n            </PopoverBody>\n          </PopoverContent>\n        </Popover>\n      ) : (\n        <Button w=\"250px\" onClick={handleConnect}>\n          Connect Web3\n        </Button>\n      )}\n    </Box>\n  );\n};\n\nexport default WalletDisplay;\n","import React from \"react\";\nimport { Button, Heading, HStack, Input, Text, VStack } from \"@chakra-ui/react\";\nimport GlobalContext, { message } from \"../context/globalContext\";\nimport { encryptMessage, formatAddress } from \"../helpers/helpers\";\nimport { ChatContentTopic } from \"../App\";\nimport { WakuMessage } from \"js-waku\";\n\nconst ChatBox = () => {\n  const { state, dispatch } = React.useContext(GlobalContext);\n  const [messageList, setList] = React.useState<message[]>([]);\n  const [msgText, setMsg] = React.useState(\"\");\n  const [toAddress, setTo] = React.useState(\"\");\n\n  React.useEffect(() => {\n    setList(state.messageList);\n  }, [state.messageList]);\n\n  const handleMessageSend = async (to: string, msgText: string) => {\n    if (!state.web3 || !state.keys) {\n      return;\n    }\n    const encryptedMessage = await encryptMessage(\n      state.keys,\n      state.addressBook![to.toLowerCase()],\n      msgText\n    );\n    const msg = WakuMessage.fromUtf8String(encryptedMessage, ChatContentTopic);\n    state.waku?.relay.send(msg);\n    setMsg(\"\");\n  };\n\n  return (\n    <VStack>\n      <HStack>\n        <VStack>\n          <Input\n            value={toAddress}\n            placeholder=\"Address\"\n            onChange={(evt) => setTo(evt.target.value)}\n          />\n        </VStack>\n        <Input\n          value={msgText}\n          placeholder=\"Enter a message\"\n          onChange={(evt) => setMsg(evt.target.value)}\n        />\n        <Button\n          minWidth=\"150px\"\n          onClick={() => {\n            handleMessageSend(toAddress, msgText);\n          }}\n        >\n          Send Message\n        </Button>\n      </HStack>\n\n      {messageList.map((msg: message) => {\n        return (\n          <HStack key={msg.from + Math.random()}>\n            <Text>\n              {formatAddress(msg.from)}: {msg.message}\n            </Text>\n          </HStack>\n        );\n      })}\n    </VStack>\n  );\n};\n\nexport default ChatBox;\n"],"sourceRoot":""}